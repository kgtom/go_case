

## 本节大纲
* [一、redis使用的数据结构](#1)
* [二、微服务api接口认证鉴权和限流](#2)
* [三、房间推荐矩阵分解](#3)
* [四、帖子feed流热度推荐](#4)
## <span id="1">一、redis使用的数据结构</span>
### 1.1 hash:
* 压缩列表ziplist
* 离散表hashTable

### 1.2 list
* ziplist
* 双端链表
### 1.3 set
* inset
* hashTable
### 1.4 zset
* ziplist
* 跳表skiplist+hashTable

### 1.5 小结
* redis同一种对象类型采用多种数据结构，原因有二，一时间和空间的考虑；二根据不同场景选择最优的对象存储
* ziplist不属于基础数据结构，是redis自研一种节约内存数据结构。它是一种有序的连续内存的结构，
  - 提高查询效率高O(1)，cpu缓存读取连续内存命中率高(L1、L2)；
  - 节约内存与数组区别在于存储元素大小及类型也可以不同
  - 限制数据数量和数据大小，考虑有二，一cup缓存大小；二数量大时，遍历复杂度O(n)，不如使用链表或者跳表
## <span id="2">二、微服务api接口认证鉴权和限流</span>
### 2.1 背景
 用户user服务，被其他系统A、B、C等系统调用，user包括 用户登录、查看用户信息、更新用户信息等api,下游系统调用user服务不同api，需要对下游系统调用api做认证鉴权
  
### 2.2 认证鉴权流程
 * 先将下游系统及其有权访问URL规则存储
 * 当前请求URL与规则匹配，匹配成功则有权限，否则无权限

### 2.3 认证鉴权具体实现
涉及两个问题：
* 1.用什么数据结构存储有权访问URL的规则？
* 2.用什么算法可以快速匹配是否有权限？

**解决方案：**
* 1.离散表：map[url]bool,实现O(1)
* 2.字符串URL数组：与请求URL比较，常见字符串匹配算法(KMP、BM、BF等)
* 3.有序数组：按照字符串URL大小存储，使用二分查找O(logN)
* 4.对于前缀匹配：trie字典树，使用场景处理带前缀的URL,将URL根据/分割的目录，构造字典树，使用二分查找O(logN)
* 5.带通配符模糊匹配：使用数组，逐个匹配，不匹配时往最近的**回溯**，毕竟这类型URL少，将这种URL与上述四种分开判断

**小结：**前三种适用于精确匹配


### 2.4 限流
* 固定窗口限流：缺点窗口期内瞬间流量大，1s内请求简单粗暴计数器加1，1s外计数器清零
* 滑动窗口限流：任何1s内请求次数都不能超过阈值，使用循环队列len=阈值+1，1s内请求，队列+1,1s外删除队尾部，优点保证任意1s内都不超过阈值，但在细时间粒度上也会存在瞬时访问的问题
* 令牌桶算法：以一个恒定的速度往桶里放入令牌，获取到令牌则处理，否则没有令牌可取时，则拒绝服务适用，
* 漏桶算法：把请求比作是水，水来了都先放进桶里，并以限定的速度出水，如果满了则拒绝访问

小结：令牌桶与漏桶适用场景不同，前者对调用这频率限流，保护自己系统不被打垮，后者保护下游(第三方)系统不被打垮，固定访问频率

## <span id="3">三、房间推荐</span>
### 3.1 数据来源：
用户在房间内对其他用户的爆灯、送礼、关注、发送消息四种事件，来判断用户喜欢的其他用户。
因为不同的事件对业务的收益并不一致，因此，对四种时间采取了带权重分析：

“关注”最重要，权值为2；
“赠送礼物”次之，权值为1；
“爆灯”权值为1；
“发送消息”权值为1；

### 3.2 矩阵分解
利用用户在房间内对其他用户的行为事件，进行矩阵分解，得到用户的向量表示，从而得到：
* A.挖掘用户潜的感兴趣用户 
* B.发现相似用户(即A的A)

### 3.3 存储 zset

* 用户潜在感兴趣的用户列表：key=prefer:USER_ID， value=USER_ID:score,USER_ID:score,...

* 用户相似用户列表：key=similar:USER_ID, value=USER_ID:similarity,USER_ID:similarity,...

### 3.4 评估
切分流量，分别进行两种A/B方案测试

## <span id="4">四、匹配房间逻辑</span>
* google-match 算法:适合排位赛，一局结束。包括四部分：前端接收玩家信息；后端存储匹配池set；启动匹配算法逻辑(过滤条件、集合交集)；自定义匹配逻辑
* 房间标签匹配：适合玩家--->房间场景。包括用户、玩家信息(hash)；玩家匹配池(set);房间池(带标签set);匹配逻辑 spop玩家池，找合适的房间池中的roomID
* 曼哈顿加权算法：K最邻近（KNN K-NearestNeighbor)的一种实现，在训练集中寻找K个与这个被预测实例最相似的训练实例。结合曼哈顿即从A地到B地所有可能路径(欧氏距离则是最短路径)。适合场景两人匹配，使用根据不同维度权重的匹配，包括期望匹配条件值；匹配条件默认权重；计算玩家权重值：defautWeight*(自己-期望值)，保存有序数组，进行分组匹配


## <span id="5">五、帖子feed流热度推荐</span>

### 5.1 背景
通过feed的热度（播放完成、喜欢、收藏、评论、曝光数据计算），生成一个feed的排序集合，推荐时，访问redis，拉去指定排序区间的feed（例如：`zrange feed_rank $rank_begin $rank_end WITHSORES`），对用户进行推荐。

### 5.2 算法介绍 
* 汤普森采样算法是一种基于beta分布族的推荐方法，其有如下特性：

* 当feed曝光量比较小时，feed的收益率（播放完成、喜欢、收藏、评论）不确定，汤普森采样算法能够为feed提供合理的曝光机会；
* 当feed曝光量充足时，feed的收益率已经比较确定，汤普森采样算法能够为feed提供较为确定的曝光机会（根据收益率）；

* 因此使用汤普森采样算法，给出feed的一个排序，是一种既兼顾探索性和合理性的热度推荐算法

### 5.3 存储 zset

* 读取zset区间值，zrange feed_rank $rank_begin $rank_end,获取推荐feed列表，过滤掉重复曝光feed，将排序在前的返回给用户。

zset key: feed_rank

zset value: {$feedID:1-$score}
