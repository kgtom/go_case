## 本节大纲
* [一、背景](#1)
* [二、常见应用场景](#2)
* [三、设计方案](#3)
* [四、总结](#4)

## <span id="1">一、背景</span>
分布式系统中，我们需要对业务量大的功能模块进行拆分，分库分表涉及到分布式唯一ID生成的问题。对ID 要求如下：
  * 全局唯一
  * 数值类型
  * 趋势递增，考虑mysql聚集索引写入
  * 信息安全，是趋势递增，而非顺序递增，顺序容易被猜测到其它id
## <span id="2">二、常见应用场景</span>
* 用户表：用户ID
* 订单表：订单ID
* 支付表：支付ID
......

## <span id="3">三、设计方案</span>
* UUID:简单易用，但不能趋势递增且字符串，存储空间大，不利于索引查询(b+树碎片)
* SnowFlake雪花算法：
    - 性能好，趋势递增，但存在时钟回拨，存在重复ID的问题
    - 解决：结合zk解决时钟问题，参考[美团方案](https://tech.meituan.com/2017/04/21/mt-leaf.html)
* mysql单实例主键自增：
  - 数值类型、效率高，但mysql单点是瓶颈读写压力大，一旦挂了，影响业务
  - 采用批量预生成生成id，参考[github](github.com/owenliang/go-id-alloc/)
* mysql多实例主键自增:
  - 解决了单机瓶颈，但使用步长策略，一旦机器和步长确定了，不容易水平扩展
  - 解决：同单实例
* redis 原子自增：
  - 使用incrby原子操作，简单高效，也会存在单机问题
  - 采用批量生成存放list，低于预警值再去生成新的

## <span id="4">四、总结</span>
* 1.结合不同场景使用不同策略
* 2.没有完美的方案，做好预警、监控很重要
