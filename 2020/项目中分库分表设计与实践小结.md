## 本节大纲
* [一、为什么分库分表](#1)
* [二、如何分库分表](#2)
* [三、分库分表后的问题](#3)
* [四、案例分析：订单库](#4)
* [四、小结](#5)



## <span id="1">一、为什么分库分表</span>
**数据库瓶颈**：数据库连接池大小
* IO瓶颈
  - 磁盘：热点数据太大，Innodb buffer pool容量有限，需要访问磁盘页上数据
  - 网络：网络带宽大小受限
* cpu瓶颈：耗时sql；不合理索引；非聚集索引

一般什么情况下分库分表的：
* 单库存储超过100G+
* 单表条数超过2kw+
* 高并发每天新增百万条记录
## <span id="2">二、如何分库分表</span>

 大多数场景下分库分表选取的字段就是查询的字段且数值类型，一般user_id。
* 水平分库分表：
   *水平分库*：按照字段(user_id或者obj_id业务id)hash将数据拆分到不同库
   *水平分表*：按照字段(user_id或者obj_id业务id)hash将数据拆分到不同表，

* 垂直分库分表：
   *垂直分库* ：按照业务表为单位，垂直拆分(微服务)；例如：订单库、用户库 
   *垂直分表* ：按照字段是否热点(活跃性)，同一个业务表热点字段与非热点字段拆分；例如：用户库(主表存储用户基本信息、辅助表存放用户扩展属性地址、星座等)
   
* 分布式数据库中间件：
  一般分 proxy和客户端两种。前者有MyCat等  后者Sharding_JDBC等
## <span id="3">三、分库分表后的问题</span>

### 3.1 查询问题
 **场景一：** 比如按照userID分表存储订单信息，现在拿着orderID做查询，方案如下：
  - 1.存储主表后，再冗余存储索引辅助表，表信息 user_id、order_id，查询时先查询索引表，再查询主表
  - 2.redis存储索引辅助表或者sql中count的数量
  - 3.冗余双份数据，数据最终一致性，此方案占用存储较大

**场景二：** 多表join问题：在业务层做数据聚合
**场景三：** 统计、排序问题：引入ES做
### 3.2 事务问题
* 1.尽量按照分库分表规则，将数据划分到同一个实例
* 2.使用消息队列异步处理，将事务分解
* 3.订阅binlog，有点小延迟

### 3.3 扩容问题
* 新旧双写
* 历史数据迁移
* 检查新的数据准确性
* 旧的逻辑下线


## <span id="4">四、案例分析：订单库的分库分表</span>

分库分表只是高并发解决方案关于db的设计方案。
### 4.1、重新定义高并发
单机服务器qps达到10000,可以称为高并发系统了；db服务器qps一般1000-1500，到达2000几乎到达顶峰了。

### 4.2、高并发瓶颈
 cpu、内存过高，数据库连接池打满(磁盘io、网络io)

### 4.3、高并发设计

* 拆分服务，分布式集群，单机能力是有限的，集群的能力解决高并发的问题
* 缓存：前端、CDN、应用层、数据库
* **分库分表**:详见场景分析
* 限流:常用算法(令牌桶、漏桶、计数器)；接入层(ngx请求、连接数)；应用层(接口)；分布式(redis+lua);限制总资源数(db连接池)
* 降级:手动降级(配置文件)；自动降级(根据系统负载、资源使用情况：超时、失败次数、故障、hystrix)；
* 回滚:事务、代码库、部署版本、数据版本、静态资源
* 设置合理超时时间和重试次数:接入层(nginx客户端、dns超时)；数据库客户端超时；业务api超时
* 隔离：进程、集群、机房、读写

### 四、场景分析：以订单库，并发10w/s为例
* 1.订单orderID的生成
 参考snowflake或者使用mysql自增机制，生成非数字递增的id,包括五部分： 分库信息2位+分表信息3位+时间戳毫秒+机器号1位预分配+自增序号(同一毫秒内) 
* 2.分库分表：用户维度拆分，比如分64个库 100张表，共6400张表；dbNO=userID%64+1 tableNO=userID%100+1;如果单机数据库并发1500--2000,则64*1500=9.6w,每秒接近10w并发。
* 3.6400张表，如果每一张表数据500w,则100*64*5000000=320亿，如果每天100w订单的话，320亿大约10年够用。
* 4.如果后续db需要扩容128台，则两种方案：
  - dba 使用工具同步数据到新库(新旧双写，导入数据、旧库下线)
  - 使用分库丢失精度？todo

* 多维度查询：订单库根据用户维度userID拆分，如果在商户维度查询的话，则三种方案：(本质是拿空间换时间)
   - 冗余方案：则商户维度冗余一份订单数据，通过mq异步处理，缺点占空间
   - 数据异构1：数据量小，存放在redis或者MongoDB中
   - 数据异构2：异构索引表尽量降低全表扫描频率。比如：主订单表按orderID分库分表会更均匀将数据分库分表存储；订单索引表按userID分库分表。查询userID=1000000订单，则先从订单索引表查出orderID，再从主表查询订单信息，两次查询。

* 5.数据存储级别
 - 核心数据，不使用缓存，直接操作db
 - 非核心，使用redis
 - 配置信息，放在内存中
* 6.限流：接入层Nginx层流量过滤
  比如：api最大处理qps10w，如果超过10w流量进来，则先放在Nginx层队列中，设置Nginx [max_conns](http://nginx.org/en/docs/http/ngx_http_upstream_module.html) 队列最大qps50w,超过50w直接返回系统繁忙。api层每10w处理即可。



### ps：阿里云rds db性能测试
[阿里云](https://yq.aliyun.com/articles/708050?spm=5176.10695662.1996646101.searchclickresult.3a2513b7M3wylv&aly_as=u4Q-KJrN)
## <span id="5">五、小结</span>
* 根据业务场景选择垂直or水平拆分
* 拆分ID保证分配均匀，选择合适的字段值
