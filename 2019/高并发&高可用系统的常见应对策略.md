## 本节大纲
* [一、解耦异步---消息队列](#1)
     * [1.redis](#11)
     * [2.kafka](#12)
* [二、项目管理](#2)
* [三、模块化设计](#3)     
* [四、通用服务的抽离](#4)
* [五、避免过度设计](#5)
* [六、数据预先处理](#6)
* [七、判断条件前置，避免无用调用](#7)
* [八、补偿机制](#8) 
* [九、高并发](#9)
* [十、高可用](#10)
* [十一、典型场景解决方案](#11)

## <span id="1"> 一、解耦异步---消息队列</span>

### 场景:
* 1.创建订单，存储db,异步发送短信给客户，此处可以使用消息队列，解耦业务存储db 与发送短信的功能。
* 2.用户登录，登录成功后发送短信通知

#### <span id="11">轻量级：redis</span>
* 常用的消息队列有NSQ、Kafka、RabbitMQ,ActiveMQ等，根据业务场景这些消息队列太大太重，发送短信功能可以使用Redis的轻量级消息队列服务。 
通常情况下，消息队列有两种模式，
* 1.发布者-订阅模式：同一条消息被所有订阅者收到
* 2.生产者-消费者模式： 同一条信息只被一个消费者处理，谁先抢到就谁处理
  
发送短信使用 生产者-消费者模式，使用 redis list 集合。

~~~
LPUSH + LPOP 
~~~

#### <span id="12">集群复杂业务场景：kafka</span>

*多个group时，注意消息消费的幂等性，常用做法：传入 key 作为唯一流水号ID；如果对消息重复不敏感，则不需要做幂等检查。
* Shopify/sarama 的producer有两种运行模式：
同步模式:把消息发给kafka之后会等待结果返回。
异步模式:把消息发给kafka之后不会等待结果返回。

## <span id="2"> 二、项目管理</span>

* 1.代码规范、代码结构的设计
* 2.知识库，整理技术上、业务上常见问题、经验、方便新成员快速理解和融入


## <span id="3"> 三、模块化设计</span>

### 背景：
* 1.根据具体业务场景，抽离独立模块
* 2.产品需求不断迭代，研发人员需要结合场景和未来拓展需求，保证代码健壮性、可维护性、可扩展
###解决方案：
* 根据业务场景，模块化设计，抽离独立模块，基于OOP,对外提供接口服务。减少系统复杂度和耦合度，利于扩展、维护
* 举例：认证服务、红包服务


##<span id="4"> 四、通用服务的抽离</span>

### 举例：oss上传、ip识别、短信通知服务等

## <span id="5"> 五、避免过度设计</span>
避免过度拆分微服务，尽量避免分布式事务

## <span id="6"> 六、数据预先处理(兜底或者容错机制)</span>
对于一些业务场景，可以提前预处理一些数据，在使用的时候就可以直接使用处理结果了，减少请求时的处理逻辑。比如：首页app列表，先快速生成cache或者兜底数据


## <span id="7">七、判断条件前置，避免无用调用</span>
分布式微服务框架，可能会调用链路很长。比如：app 调用http 服务时，可以将判断用户是否有权限，判断用户领券次数等前置在网关层，避免无用服务进入链路服务。

##  <span id="8">八、补偿机制</span>
 分布式事务，处理数据一致性，采用补偿机制，即：后台task去执行，注意函数幂等性 和数据的去重
 

##  <span id="9">高并发</span>
高并发除了需要对服务器进行垂直扩展(升配置)和水平扩展(增加机器)之外，作为后端开发可以通过高并发优化：

1.cache： 
服务端cache: 读redis ，注意缓存穿透(将db查出空值写入cache,避免被刷db)和缓存雪崩(可以加互斥锁或者对具体方法做hystrix、RateLimiter等)
客户端cache:请求带着版本号，如果与服务器版本号一致，则不返回数据，反之，服务器生成最新数据给客户端，使用场景：更新频率不高的数据
CDN cache:前端静态资源放入cdn,注意前端更新静态资源时，需要刷新cdn缓存或者 每次更新请求路径带上版本号

2.异步处理
接到客户端请求，写入MQ，返回用户，后台任务task 消费MQ数据，缺点 牺牲客户体验，优点 削峰解耦，服务稳定性
![mq](https://upload-images.jianshu.io/upload_images/726039-8fc68b92e5ed9db4.png?imageMogr2/auto-orient/
)
场景：大促发红包、跨多个服务可以运行异步处理的业务模块



## <span id="10">高可用</span>
* 负载均衡(nginx)
* 限流(rate、redis) ：具体方法、秒杀活动，控制请求量，避免超卖
* 降级(手动自动、自动到达阈值降级 hystrix)：
* 版本回滚：降级解决不了问题，则回滚上一个版本

 高可用技术手段看：数据和服务冗余备份+故障转移(一组服务、数据多个节点互为备份，一个节点有故障，其他节点补上)

## <span id="11">典型场景解决方案</span>

1.防刷、防羊毛党
解决方案：
a.校验请求的合法性：请求参数校验、请求header校验、user-agent、请求参数签名校验、设备限制、ip限制、验证码和手机sms、自建黑名单
b.业务风控：限制人参与次数、限制设备、ip参与次数、

2.并发问题
场景举例：登录app 签到送积分，用户点击多长签到或者模拟多次签到行为，假设用户A并发两次请求，这时同时进入查询到今日未签到，结果：送两次积分，增加两次签到记录
解决：
a.请求到后台时，互斥锁，有且只有一个请求拿到lock，去查询是否签到过
b.在db中将签到日期+userID 做唯一索引，
建议使用lock,减少过多请求到达db

3.库存负数
场景举例：库存db 只有1件商品，A、B、C 三个用户同时查询还有库存，于是下单，避免超卖
解决方案：update cnt=cnt-1 where cnt>=1

4.库存扣减
结合业务场景，常用：redis+MQ，做好压测，给出限流阈值
redis使用lua脚步的原子性避免超卖情况，
MQ 异步处理库存业务数据，例如 存储db 、 发送sms，注意数据一致性和数据去重

> reference:
* [jianshu](https://www.jianshu.com/p/51f2e29e4871)

