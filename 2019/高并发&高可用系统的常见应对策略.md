## 本节大纲
* [一、解耦异步---消息队列](#1)
     * [1.redis](#11)
     * [2.kafka](#12)
* [二、项目管理](#2)
* [三、模块化设计](#3)     
* [四、通用服务的抽离](#4)
* [五、避免过度设计](#5)
* [六、数据预先处理](#6)
* [七、判断条件前置，避免无用调用](#7)
* [八、补偿机制](#8)

## <span id="1"> 一、解耦异步---消息队列</span>

### 场景:
* 1.创建订单，存储db,异步发送短信给客户，此处可以使用消息队列，解耦业务存储db 与发送短信的功能。
* 2.用户登录，登录成功后发送短信通知

#### <span id="11">轻量级：redis</span>
* 常用的消息队列有NSQ、Kafka、RabbitMQ,ActiveMQ等，根据业务场景这些消息队列太大太重，发送短信功能可以使用Redis的轻量级消息队列服务。 
通常情况下，消息队列有两种模式，
* 1.发布者-订阅模式：同一条消息被所有订阅者收到
* 2.生产者-消费者模式： 同一条信息只被一个消费者处理，谁先抢到就谁处理
  
发送短信使用 生产者-消费者模式，使用 redis list 集合。

~~~
LPUSH + LPOP 
~~~

#### <span id="12">集群复杂业务场景：kafka</span>

*多个group时，注意消息消费的幂等性，常用做法：传入 key 作为唯一流水号ID；如果对消息重复不敏感，则不需要做幂等检查。
* Shopify/sarama 的producer有两种运行模式：
同步模式:把消息发给kafka之后会等待结果返回。
异步模式:把消息发给kafka之后不会等待结果返回。

## <span id="2"> 二、项目管理</span>

* 1.代码规范、代码结构的设计
* 2.知识库，整理技术上、业务上常见问题、经验、方便新成员快速理解和融入


## <span id="3"> 三、模块化设计</span>

### 背景：
* 1.根据具体业务场景，抽离独立模块
* 2.产品需求不断迭代，研发人员需要结合场景和未来拓展需求，保证代码健壮性、可维护性、可扩展
###解决方案：
* 根据业务场景，模块化设计，抽离独立模块，基于OOP,对外提供接口服务。减少系统复杂度和耦合度，利于扩展、维护
* 举例：认证服务、红包服务


##<span id="4"> 四、通用服务的抽离</span>

### 举例：oss上传、ip识别、短信通知服务等

## <span id="5"> 五、避免过度设计</span>
避免过度拆分微服务，尽量避免分布式事务

## <span id="6"> 六、数据预先处理(兜底或者容错机制)</span>
对于一些业务场景，可以提前预处理一些数据，在使用的时候就可以直接使用处理结果了，减少请求时的处理逻辑。比如：首页app列表，先快速生成cache或者兜底数据


## <span id="7">七、判断条件前置，避免无用调用</span>
分布式微服务框架，可能会调用链路很长。比如：app 调用http 服务时，可以将判断用户是否有权限，判断用户领券次数等前置在网关层，避免无用服务进入链路服务。

##  <span id="8">八、补偿机制</span>
 分布式事务，处理数据一致性，采用补偿机制，即：后台task去执行，注意函数幂等性 和数据的去重
 


> reference:
* [jianshu](https://www.jianshu.com/p/51f2e29e4871)

